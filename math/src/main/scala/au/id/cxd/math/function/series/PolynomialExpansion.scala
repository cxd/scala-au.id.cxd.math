package au.id.cxd.math.function.series

import au.id.cxd.math.collection.{Node, Trie}
import au.id.cxd.math.count.{Choose, Permutation}
import breeze.linalg.{DenseMatrix, DenseVector}

import scala.collection.mutable

/**
  * Expand a supplied matrix as series of polynomial factors.
  *
  *
  * This procedure can be used to generate features
  * for an input vector X.
  *
  * For example if X has 2 columns and we seek a degree n = 2 polynomial
  * (a, b) will have (a, b, a&#94;2, 2ab, b&#94;2)  which is 3 extra features
  *
  * $$
  * (a, b, c)&#94;n = (a, b, b, a&#94;2, ab, b&#94;2, bc, c&#94;2, x&#94;3, x&#94;2b, x&#94;2c, ab&#94;2, abc, ac&#94;2, b&#94;3, c&#94;3, ..., )
  * $$
  *
  * We can use the multinomial theorem to do the expansion of the sum
  *
  * $$
  * (x_1 + x_2 + \cdots + x_m)&#94;2 = \sum_{k_1+k_2+\cdots k_m = n}\left( n \choose {k_1, k_2, \cdots , \k_m \right \prod_{1\leqt\leqm} x_t&#94;{k_t}
  * $$
  *
  * the coefficients up to n can be determined using the rule
  *
  * $$
  * \left( n \choose {k_1, k_2, k_3, ..., k_m} \right)
  * $$
  *
  * where for any combination of $k$ $\sum_{i=1}&#94;m k$ must equal $n$.
  *
  * $m$ represents the number of columns in matrix $X$ and has
  *
  * the number of combinations of coefficients would be ${n + m - 1} \choose {m - 1}$.
  *
  * The theorem is described here:
  *
  * https://en.wikipedia.org/wiki/Multinomial_theorem
  *
  * @param X      - the matrix to transform
  * @param degree the degree of the polynomial
  *
  *
  *               Created by cd on 23/04/2016.
  */
class PolynomialExpansion(val X: DenseMatrix[Double], val degree: Int) {


  /**
    * determine how many coefficients there will be in total
    *
    * @return
    */
  def count(): Int = {
    val a = X.cols + degree - 1
    val b = degree - 1
    val total = Choose(a)(b)
    total.toInt
  }

  /**
    * determine the number of permutations possible for the columns in X choosing degree of polynomial.
    *
    * I $X$ has $k$ columns the number of permutations of powers will be: $P_k&#94;k$
    *
    * @return
    */
  def permutations(): Int = Permutation(X.cols)(X.cols).toInt


  /**
    * transform X into the polynomial of supplied degree
    *
    * the rows represent the set of coefficients
    * the columns represent the powers of each column of X
    * for each row of X, iterate the rows of the powers,
    * each new column is generated by the product of the columns of X raised to the columns in powers(row, ::)
    *
    * The resulting matrix has dimensions rows of X and columns cols X + cols X + degree -1 choose degree - 1
    */
  def transform() = {
    val powers = X.cols > 1 match {
      case true => generatePowers
      case _ => {
        DenseMatrix.tabulate[Double](degree, 1){ case (i, j) => i+1 }
      }
    }
    // the rows represent the set of coefficients
    // the columns represent the powers of each column of X
    // for each row of X, iterate the rows of the powers, each new column is generated by the product of the columns of powers(row, ::)
    val M = DenseMatrix.zeros[Double](X.rows, powers.rows + X.cols)
    M(::,0 until X.cols) := X
    val offset = X.cols
    val M2 = DenseMatrix.tabulate[Double](X.rows, powers.rows) {
      case (i, j) => {
        val row = powers(j, ::) .inner
        val raised = for(k <- 0 until row.length) yield Math.pow(X(i, k), row(k))
        val prod = raised.reduce { (a, b) => a*b }
        prod
      }
    }
    M(::,offset until powers.rows + X.cols) := M2
    M
  }

  /**
    * build a series of powers
    *
    * this is a permutation of series that sum to n
    *
    * for example for n = 3 and m = 3 we expect 10 coefficients where the value is
    *
    * $3 = 3 + 0$ or $3 = 2 + 1 + 0 or 3 = 1+1+1$
    *
    * 3+0
    * (3,0,0)
    * (0,3,0)
    * (0,0,3)
    *
    * 2+1
    * (2,1,0)
    * (2,0,1)
    * (1,2,0)
    * (1,0,2)
    * (0,2,1)
    * (0,1,2)
    *
    * and the series:
    * (1,1,1)
    *
    * Yielding the vector $(a, b, c, a&#94;3, b&#94;3, c&#94;3, a&#94;2b, a&#94;2c, ab&#94;2, ac&#94;2, b&#94;2c, bc&#94;2)$
    *
    * This is a combinatorial problem, where we first need to determine the number of sets of summations to $n$
    *
    * $$
    * n = \left{ (a_1, b_1, ..., p_2), (a_2, b_2, ..., p_2), ..., (a_k, b_k, ..., p_k) \right}
    * $$
    * Then the number of permutations of those summations which will be $P_p&#94;p$ permutations for each set.
    *
    * @return
    */
  def generatePowers() = {
    // compute the set of vlaues that sum to n other than n + 0 and 1's
    // include degree n in the sequence.
    val sequence = for (i <- 0 to degree) yield i
    // pad the sequence
    val seed = pad(X.cols)(sumUntil(degree)(sequence))

    // use a diagonal matrix of rank X.cols to generate the powers for set1
    // this is essentially a diagonal matrix where the value is the degree of the polynomial
    val mat1 = DenseMatrix.tabulate[Double](X.cols, X.cols) {
      case (i, j) => i == j match {
        case true => degree
        case _ => 0.0
      }
    }

    val rows = permutations
    // the permutations of powers in a table that is number of permutations x X.cols
    val mat2 = generateTrie(seed, 0, (0, 0))


    // we have the two special cases of set1 and set2
    // now we need to generate the permutations of the original padded set.

    val powers = DenseMatrix.ones[Double](mat1.rows + mat2.rows + 1, X.cols)
    powers(0 until mat1.rows, ::) := mat1
    powers(mat1.rows until mat1.rows + mat2.rows, ::) := mat2
    // the last row is unassigned and will equal 1.
    powers
  }

  /**
    * note generating the powers can be achieved as an m-way tree where the root is m-way and each path is (n - depth)-way subtree
    * this is a series of expansions down each path were each subtree is the subset of the prior path
    *
    * generate the trie where the matrix M is of rows $P_k&#94;k and cols X.cols
    * the coordinates represent the level of the traversal (or row) and the column (or position in the seed vector)
    *
    * TODO: continue work on reading off the powers from the trie after it is generated.
    *
    * @param seed
    * @param level
    * @param parent
    * @return
    */
  def generateTrie(seed: Seq[Int], level: Int, parent: (Int, Int)): DenseMatrix[Double] = {
    def innerGenerate(seed1:Seq[Int], previous:Seq[Int], level:Int):Trie[Int] = {
      val nodes = seed1 map {
        i => Node(i, previous, innerGenerate(seed1 filterNot { j => j == i }, previous :+ i, level + 1))
      }
      Trie (nodes)
    }
    val trie = innerGenerate(seed, Seq[Int](), 0)
    // now given the trie convert it into a sequence of vectors for each depth first traversal.
    def block (accum:(mutable.Seq[DenseVector[Double]], Int), node:Node[Int]) = {
        node.children.nodes.length == 0 match {
          case false => {
            accum
          }
          case true => {
            val state = accum._1
            val i = accum._2
            val sequence = (node.prefix :+ node.data)
            val next = state :+ DenseVector.tabulate[Double](sequence.length) { n => sequence(n) }
            (next, 0)
          }
        }
      }

    val accum = mutable.Seq[DenseVector[Double]]()
    val next = trie.fold((accum, 0))(block)
    val M = DenseMatrix.zeros[Double](next._1.length, seed.length)
    next._1.foldLeft((M, 0)) {
      (state, vector) => {
        val M1 = state._1
        val row = state._2
        val result = vector.toArray.foldLeft((M1, 0)) { (pair, value) => {
          val M2 = pair._1
          val j = pair._2
          M2(row, j) = value
          (M2, j+1)
        }}
        (result._1, row+1)
      }
    }
    M
  }

  /**
    * Collate the set of values in sequence k until they summate to n
    *
    * @param n
    * @param seq
    * @return
    */
  def sumUntil(n: Int)(seq: Seq[Int]) =
    seq.foldLeft((0, List[Int]())) {
      (accum, k) => {
        val total = accum._1
        val set = accum._2
        accum._1 == n match {
          case true => (n, set)
          case false => (total + k, set :+ k)
        }
      }
    }._2

  /**
    * pad a sequence with zeroes until it is length n
    *
    * @param n
    * @param seq
    * @return
    */
  def pad(n: Int)(seq: Seq[Int]) =
    for (i <- 0 until n) yield i < seq.length match {
      case true => seq(i)
      case _ => 0
    }

}

object PolynomialExpansion {
  /**
    * transform X into the n degree polynomial.
    * @param X
    * @param degree
    * @return
    */
  def apply(X: DenseMatrix[Double], degree: Int): DenseMatrix[Double] = new PolynomialExpansion(X, degree).transform
}
